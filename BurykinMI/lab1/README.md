# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Цель работы
Изучить базовые операции обработки изображений и разработать библиотеку фильтров, используя только низкоуровневые операции над матрицами изображений без применения высокоуровневых функций библиотеки OpenCV.

---

## Структура проекта

```
BurykinMI/
└── lab1/
    ├── main.py          # Главный скрипт для запуска фильтров
    ├── filters.py       # Реализация функций фильтров
    ├── README.md        # Описание работы
    ├── input.jpg        # Тестовое изображение
    ├── lensflare.jpg    # Текстура блика (для фильтра flare)
    └── texture.jpg      # Текстура бумаги (для фильтра texture)
```
---

## Описание реализованных функций

1. **Изменение разрешения изображения**  
   **Функция**: `resize_image(img, scale)`  
   **Описание**: Масштабирование изображения выполняется путём выбора пикселей из исходного изображения на основе линейной интерполяции индексов. Для нового размера `(new_h, new_w)` вычисляются индексы пикселей с помощью `np.linspace`, и значения берутся из ближайших пикселей исходного изображения.  
   **Алгоритм**:
   ```
   new_h = int(h * scale), new_w = int(w * scale)
   y_idx = linspace(0, h-1, new_h)
   x_idx = linspace(0, w-1, new_w)
   resized = img[y_idx, x_idx]
   ```

2. **Фотоэффект сепии**  
   **Функция**: `apply_sepia(img)`  
   **Описание**: Применяется матричное преобразование для каждого пикселя изображения с использованием матрицы сепии:
   ```
   | 0.272  0.534  0.131 |
   | 0.349  0.686  0.168 |
   | 0.393  0.769  0.189 |
   ```
   Результат обрезается в диапазоне `[0, 255]` с помощью `np.clip` для сохранения корректных значений цвета.  
   **Алгоритм**:
   ```
   sepia_img = img @ sepia_filter.T
   sepia_img = clip(sepia_img, 0, 255)
   ```

3. **Фотоэффект виньетки**  
   **Функция**: `apply_vignette(img, strength)`  
   **Описание**: Создаётся двумерная маска яркости на основе экспоненциального распределения, зависящего от расстояния пикселя от центра изображения. Маска умножается на изображение, затемняя края.  
   **Формула**:
   ```
   mask = exp(-r^2 / (2 * strength^2)), где r — расстояние от центра
   vignette = img * mask
   ```
   **Алгоритм**:
   ```
   X, Y = meshgrid(linspace(-1, 1, cols), linspace(-1, 1, rows))
   r = sqrt(X^2 + Y^2)
   mask = exp(-r^2 / (2 * strength^2))
   vignette = clip(img * mask, 0, 255)
   ```

4. **Пикселизация прямоугольной области**  
   **Функция**: `pixelate_region(img, x1, y1, x2, y2, pixel_size)`  
   **Класс**: `PixelateSelector`  
   **Описание**: Реализован интерактивный выбор области для пикселизации с помощью мыши. Пользователь зажимает левую кнопку мыши для выбора первой точки и отпускает для выбора второй точки. Выбранная область разбивается на блоки размером `pixel_size × pixel_size`. Каждый блок заполняется средним значением цвета пикселей в нём.  
   **Интерактивный режим**:
   - `EVENT_LBUTTONDOWN` — начало выделения области (первая точка)
   - `EVENT_MOUSEMOVE` — отображение прямоугольника выделения
   - `EVENT_LBUTTONUP` — завершение выделения (вторая точка) и применение эффекта
   - Клавиша `q` или `ESC` — выход из режима выделения
   
   **Алгоритм пикселизации**:
   ```
   for y in range(y1, y2, pixel_size):
       for x in range(x1, x2, pixel_size):
           block = region[y:y+pixel_size, x:x+pixel_size]
           region[y:y+pixel_size, x:x+pixel_size] = mean(block)
   ```

5. **Прямоугольная одноцветная рамка**  
   **Функция**: `add_rectangular_frame(img, color, thickness)`  
   **Описание**: Пиксели по краям изображения шириной `thickness` закрашиваются заданным цветом.  
   **Алгоритм**:
   ```
   img[:thickness, :] = color
   img[-thickness:, :] = color
   img[:, :thickness] = color
   img[:, -thickness:] = color
   ```

6. **Фигурная одноцветная рамка**  
   **Функция**: `add_figure_frame(img, color, thickness, frame_type)`  
   **Описание**: Создаётся маска для рамки типа `wave` (синусоидальная форма) или `triangle` (чередующиеся полосы). Пиксели, соответствующие маске, закрашиваются заданным цветом.  
   **Алгоритм для `wave`**:
   ```
   y = sin(x / 20) * 10 + thickness
   mask[:y[i], i] = 1
   mask[-y[i]:, i] = 1
   img[mask > 0] = color
   ```

7. **Эффект бликов объектива**  
   **Функция**: `add_lens_flare(img, texture_path, intensity)`  
   **Описание**: Накладывается текстура блика из внешнего файла изображения. Текстура масштабируется под размер исходного изображения с использованием интерполяции по ближайшему соседу (метод аналогичный функции `resize_image`). Затем текстура накладывается с использованием режима смешивания "Screen" (осветление), который создаёт эффект световых бликов.  
   **Формула режима Screen**:
   ```
   result = 1 - (1 - img) * (1 - texture * intensity)
   ```
   **Алгоритм**:
   ```
   flare_texture = imread(texture_path)
   # Масштабирование через интерполяцию по ближайшему соседу
   y_idx = linspace(0, flare_h-1, h).astype(int)
   x_idx = linspace(0, flare_w-1, w).astype(int)
   flare_resized = flare_texture[y_idx, x_idx]
   # Нормализация и наложение
   img_float = img / 255.0
   flare_float = flare_resized / 255.0
   result = 1 - (1 - img_float) * (1 - flare_float * intensity)
   result = clip(result * 255, 0, 255)
   ```

8. **Текстура акварельной бумаги**  
   **Функция**: `add_paper_texture(img, texture_path, intensity)`  
   **Описание**: Накладывается текстура бумаги из внешнего файла изображения. Текстура масштабируется под размер исходного изображения с использованием интерполяции по ближайшему соседу. Затем текстура конвертируется в оттенки серого с помощью взвешенного среднего каналов (формула luminosity: `Gray = 0.114*B + 0.587*G + 0.299*R`). Результат накладывается с использованием режима смешивания "Multiply" (умножение), который создаёт эффект текстурированной поверхности.  
   **Формула режима Multiply**:
   ```
   result = img * (1 - intensity + texture * intensity)
   ```
   **Алгоритм**:
   ```
   paper_texture = imread(texture_path)
   # Масштабирование через интерполяцию по ближайшему соседу
   y_idx = linspace(0, paper_h-1, h).astype(int)
   x_idx = linspace(0, paper_w-1, w).astype(int)
   paper_resized = paper_texture[y_idx, x_idx]
   # Конвертация в оттенки серого через взвешенное среднее
   paper_gray = paper_resized[:,:,0] * 0.114 + 
                paper_resized[:,:,1] * 0.587 + 
                paper_resized[:,:,2] * 0.299
   paper_normalized = paper_gray / 255.0
   # Наложение текстуры
   img_float = img / 255.0
   result = img_float * (1 - intensity + paper_normalized * intensity)
   result = clip(result * 255, 0, 255)
   ```

---

## Запуск программы

Скрипт `main.py` принимает параметры командной строки:
```bash
python main.py <путь_к_изображению> <тип_фильтра> [параметры]
```

### Примеры использования:

**Базовые фильтры:**
```bash
python main.py input.jpg sepia
python main.py input.jpg resize 0.4
python main.py input.py vignette 0.7
python main.py input.jpg frame 30
python main.py input.jpg figframe 25 triangle
```

**Пикселизация (интерактивный режим):**
```bash
python main.py input.jpg pixelate 15
```
После запуска:
1. Зажмите левую кнопку мыши и выделите область
2. Отпустите кнопку — область будет пикселизирована
3. Можно выделять несколько областей подряд
4. Нажмите `q` или `ESC` для завершения

**Текстурные эффекты:**
```bash
# Блик (требуется файл текстуры)
python main.py input.jpg flare lensflare.jpg 0.8 

# Бумага (требуется файл текстуры)
python main.py input.jpg texture texture.jpg 0.8
```

После выполнения откроются два окна:
- **Original** — исходное изображение
- **Result** — изображение после применения фильтра

Для закрытия окон нажмите любую клавишу.

---

## Требования к текстурам

Для фильтров `flare` и `texture` необходимо предоставить файлы текстур:

**Текстура блика** (`flare`):
- Рекомендуется использовать изображение светового блика на прозрачном или тёмном фоне
- Форматы: PNG (с прозрачностью), JPG

**Текстура бумаги** (`texture`):
- Рекомендуется использовать изображение текстуры акварельной или обычной бумаги
- Форматы: JPG, PNG

---

## Используемые библиотеки

- **NumPy**: Для всех матричных операций и обработки изображений:
  - Масштабирование изображений через индексирование массивов
  - Матричные преобразования цветов
  - Создание и применение масок
  - Конвертация цветовых пространств через взвешенное среднее
  - Все вычислительные операции фильтров
  
- **OpenCV (cv2)**: Только для базовых операций ввода-вывода и интерфейса:  
  - `cv2.imread()` — чтение изображений и текстур
  - `cv2.imshow()` — отображение изображений
  - `cv2.waitKey()` и `cv2.destroyAllWindows()` — управление окнами
  - `cv2.rectangle()` — отрисовка прямоугольника выделения (только для визуализации в интерактивном режиме)
  - `cv2.setMouseCallback()` — обработка событий мыши для интерактивного выбора области
  
- **argparse**: Для обработки аргументов командной строки (путь к изображению, тип фильтра, параметры).
