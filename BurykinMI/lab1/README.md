# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Цель работы
Изучить базовые операции обработки изображений и разработать библиотеку фильтров, используя только низкоуровневые операции над матрицами изображений без применения высокоуровневых функций библиотеки OpenCV.

---

## Структура проекта

```
BurykinMI/
└── lab1/
    ├── main.py # Главный скрипт для запуска фильтров
    ├── filters.py # Реализация функций фильтров
    ├── README.md # Описание работы
    └── input.jpg # Тестовое изображение
```
---

## Описание реализованных функций

1. **Изменение разрешения изображения**  
   **Функция**: `resize_image(img, scale)`  
   **Описание**: Масштабирование изображения выполняется путём выбора пикселей из исходного изображения на основе линейной интерполяции индексов. Для нового размера `(new_h, new_w)` вычисляются индексы пикселей с помощью `np.linspace`, и значения берутся из ближайших пикселей исходного изображения.  
   **Алгоритм**:
   ```
   new_h = int(h * scale), new_w = int(w * scale)
   y_idx = linspace(0, h-1, new_h)
   x_idx = linspace(0, w-1, new_w)
   resized = img[y_idx, x_idx]
   ```

2. **Фотоэффект сепии**  
   **Функция**: `apply_sepia(img)`  
   **Описание**: Применяется матричное преобразование для каждого пикселя изображения с использованием матрицы сепии:
   ```
   | 0.272  0.534  0.131 |
   | 0.349  0.686  0.168 |
   | 0.393  0.769  0.189 |
   ```
   Результат обрезается в диапазоне `[0, 255]` с помощью `np.clip` для сохранения корректных значений цвета.  
   **Алгоритм**:
   ```
   sepia_img = img @ sepia_filter.T
   sepia_img = clip(sepia_img, 0, 255)
   ```

3. **Фотоэффект виньетки**  
   **Функция**: `apply_vignette(img, strength)`  
   **Описание**: Создаётся двумерная маска яркости на основе экспоненциального распределения, зависящего от расстояния пикселя от центра изображения. Маска умножается на изображение, затемняя края.  
   **Формула**:
   ```
   mask = exp(-r^2 / (2 * strength^2)), где r — расстояние от центра
   vignette = img * mask
   ```
   **Алгоритм**:
   ```
   X, Y = meshgrid(linspace(-1, 1, cols), linspace(-1, 1, rows))
   r = sqrt(X^2 + Y^2)
   mask = exp(-r^2 / (2 * strength^2))
   vignette = clip(img * mask, 0, 255)
   ```

4. **Пикселизация прямоугольной области**  
   **Функция**: `pixelate_region(img, x1, y1, x2, y2, pixel_size)`  
   **Описание**: Выбранная область разбивается на блоки размером `pixel_size × pixel_size`. Каждый блок заполняется средним значением цвета пикселей в нём.  
   **Алгоритм**:
   ```
   for y in range(y1, y2, pixel_size):
       for x in range(x1, x2, pixel_size):
           block = region[y:y+pixel_size, x:x+pixel_size]
           region[y:y+pixel_size, x:x+pixel_size] = mean(block)
   ```

5. **Прямоугольная одноцветная рамка**  
   **Функция**: `add_rectangular_frame(img, color, thickness)`  
   **Описание**: Пиксели по краям изображения шириной `thickness` закрашиваются заданным цветом.  
   **Алгоритм**:
   ```
   img[:thickness, :] = color
   img[-thickness:, :] = color
   img[:, :thickness] = color
   img[:, -thickness:] = color
   ```

6. **Фигурная одноцветная рамка**  
   **Функция**: `add_figure_frame(img, color, thickness, frame_type)`  
   **Описание**: Создаётся маска для рамки типа `wave` (синусоидальная форма) или `triangle` (чередующиеся полосы). Пиксели, соответствующие маске, закрашиваются заданным цветом.  
   **Алгоритм для `wave`**:
   ```
   y = sin(x / 20) * 10 + thickness
   mask[:y[i], i] = 1
   mask[-y[i]:, i] = 1
   img[mask > 0] = color
   ```

7. **Эффект бликов объектива**  
   **Функция**: `add_lens_flare(img, center, intensity)`  
   **Описание**: Создаётся радиальная световая маска, убывающая по экспоненциальному закону от центра. Маска окрашивается в тёплые оттенки и добавляется к изображению.  
   **Формула**:
   ```
   flare = exp(-(r / (0.5 * w))^2), где r — расстояние от центра
   flare_img = img + flare * flare_color * intensity
   ```

8. **Текстура акварельной бумаги**  
   **Функция**: `add_paper_texture(img, scale, intensity)`  
   **Описание**: Генерируется случайный шум, который сглаживается усреднением по окну размером `scale`. Нормализованная текстура умножается на изображение с заданной интенсивностью.  
   **Алгоритм**:
   ```
   noise = random.normal(0.5, 0.2, shape)
   for y, x in image:
       region = noise[y:y+scale, x:x+scale]
       smoothed[y, x] = mean(region)
   texture = (smoothed - min(smoothed)) / (max(smoothed) - min(smoothed))
   img_textured = img * (1 - intensity + texture * intensity)
   ```

---


## Запуск программы

Скрипт `main.py` принимает параметры командной строки:
```bash
python main.py <путь_к_изображению> <тип_фильтра> [параметры]
```

Примеры:
```bash
python main.py input.jpg sepia
python main.py input.jpg resize 0.4
python main.py input.jpg vignette 0.7
python main.py input.jpg pixelate 100 100 400 400 15
python main.py input.jpg frame 30
python main.py input.jpg figframe 25 triangle
python main.py input.jpg flare
python main.py input.jpg texture 11 0.35
```

После выполнения откроются два окна:
- **Original** — исходное изображение.
- **Result** — изображение после применения фильтра.

Для закрытия окон нажмите любую клавишу.

---
## Используемые библиотеки

- **NumPy**: Для матричных операций и работы с массивами изображений. Используется для всех вычислений фильтров.  
- **OpenCV (cv2)**: Только для базовых операций:  
  - `cv2.imread()` — чтение изображений.  
  - `cv2.imshow()` — отображение изображений.  
  - `cv2.waitKey()` и `cv2.destroyAllWindows()` — управление окнами.  
- **argparse**: Для обработки аргументов командной строки (путь к изображению, тип фильтра, параметры).
